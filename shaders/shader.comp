#define W 8
#define MAX_B W*W*W

struct Vertex {
    float3 position;
    float2 texCoord;
};

RWStructuredBuffer<Vertex> vertices : register(u4);
RWStructuredBuffer<uint> indices : register(u5);

struct DrawCommand {
    uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
};

RWStructuredBuffer<DrawCommand> drawCommand : register(u3);
#define indexCount drawCommand[0].indexCount
#define instanceCount drawCommand[0].instanceCount
#define firstIndex drawCommand[0].firstIndex
#define vertexOffset drawCommand[0].vertexOffset
#define firstInstance drawCommand[0].firstInstance

struct VoxelTreeNode {
    uint height;
    uint children[4];
    uint leaf;
    int x;
    int y;
};

RWStructuredBuffer<VoxelTreeNode> nodes : register(u0);

struct VoxelTreeLeaf {
    uint blocks[MAX_B];
};

RWStructuredBuffer<VoxelTreeLeaf> leaves : register(u1);

struct VoxelTreeInfo {
    uint    rootNodeIndex;
    uint    lastNodeIndex;
    uint    lastLeafIndex;
};

RWStructuredBuffer<VoxelTreeInfo> voxelTreeInfo : register(u2);
#define rootNodeIndex voxelTreeInfo[0].rootNodeIndex
#define lastNodeIndex voxelTreeInfo[0].lastNodeIndex
#define lastLeafIndex voxelTreeInfo[0].lastLeafIndex

// Index of the lastly available vertex buffer index
static uint vInd = 0;
// Index of the lastly available index buffer index
static uint iInd = 0;
static uint currentLeafIndex = 0;
static uint currentNodeIndex = 0;

uint addVertex(float3 pos, float2 texCoord);
void addSquare(uint a, uint b, uint c, uint d);
void setupDrawCommand();
void drawCube(int x, int y, int z);
uint getBlock(int x, int y, int z);
uint getBlockInd(int x, int y, int z);

[numthreads(1, 1, 1)]
void main(uint3 globalInvocationID : SV_DispatchThreadID)
{
	printf("indexCount0: %u", iInd);
    uint index = globalInvocationID.x;
    for (currentNodeIndex = 0; currentNodeIndex < lastNodeIndex; currentNodeIndex ++) {
        if (nodes[currentNodeIndex].leaf != -1) {
            currentLeafIndex = nodes[currentNodeIndex].leaf;
            for (int x = 0; x < W; x ++) {
                for (int y = 0; y < W; y ++) {
                    for (int z = 0; z < W; z ++) {
                        if (leaves[currentLeafIndex].blocks[getBlockInd(x, y, z)] > 0) {
                            drawCube(x, y, z);
                        }
                    }
                }
            }
        }
    }

    setupDrawCommand();
}

uint addVertex(float3 pos, float2 texCoord) {
    vertices[vInd].position = pos;
    vertices[vInd].texCoord = texCoord;
    return vInd++;
}

void addSquare(uint a, uint b, uint c, uint d) {
    indices[iInd++] = a;
    indices[iInd++] = b;
    indices[iInd++] = c;

    indices[iInd++] = c;
    indices[iInd++] = d;
    indices[iInd++] = a;
}

void setupDrawCommand() {
    indexCount = iInd;
    instanceCount = 1;
    firstIndex = 0;
    vertexOffset = 0;
    firstInstance = 0;

	printf("indexCount: %u", iInd);
}

void drawCube(int x, int y, int z) {
    x += W * nodes[currentNodeIndex].x;
    y += W * nodes[currentNodeIndex].y;

    // Back side
    uint a, b, c, d;
    if (getBlock(x, y, z - 1) == 0) {
        a = addVertex(float3(x + 1, y, z), float2(0, 1));
        b = addVertex(float3(x, y, z), float2(1, 1));
        c = addVertex(float3(x, y + 1, z), float2(1, 0));
        d = addVertex(float3(x + 1, y + 1, z), float2(0, 0));
        addSquare(a, b, c, d);
    }

    // Front side
    if (getBlock(x, y, z + 1) == 0) {
        a = addVertex(float3(x, y, z + 1), float2(0, 1));
        b = addVertex(float3(x + 1, y, z + 1), float2(1, 1));
        c = addVertex(float3(x + 1, y + 1, z + 1), float2(1, 0));
        d = addVertex(float3(x, y+ 1, z + 1), float2(0, 0));
        addSquare(a, b, c, d);
    }

    // Left side
    if (getBlock(x - 1, y, z) == 0) {
        a = addVertex(float3(x, y, z), float2(0, 1));
        b = addVertex(float3(x, y, z + 1), float2(1, 1));
        c = addVertex(float3(x, y + 1, z + 1), float2(1, 0));
        d = addVertex(float3(x, y + 1, z), float2(0, 0));
        addSquare(a, b, c, d);
    }

    // Right side
    if (getBlock(x + 1, y, z) == 0) {
        a = addVertex(float3(x + 1, y, z + 1), float2(0, 1));
        b = addVertex(float3(x + 1, y, z), float2(1, 1));
        c = addVertex(float3(x + 1, y + 1, z), float2(1, 0));
        d = addVertex(float3(x + 1, y + 1, z + 1), float2(0, 0));
        addSquare(a, b, c, d);
    }

    // Bottom side
    if (getBlock(x, y - 1, z) == 0) {
        a = addVertex(float3(x, y, z + 1), float2(0, 1));
        b = addVertex(float3(x, y, z), float2(1, 1));
        c = addVertex(float3(x + 1, y, z), float2(1, 0));
        d = addVertex(float3(x + 1, y, z + 1), float2(0, 0));
        addSquare(a, b, c, d);
    }

    // Top side
    if (getBlock(x, y + 1, z) == 0) {
        a = addVertex(float3(x, y + 1, z), float2(0, 1));
        b = addVertex(float3(x, y + 1, z + 1), float2(1, 1));
        c = addVertex(float3(x + 1, y + 1, z + 1), float2(1, 0));
        d = addVertex(float3(x + 1, y + 1, z), float2(0, 0));
        addSquare(a, b, c, d);
    }
}

uint getBlock(int x, int y, int z) {
    if (
    x < 0 || x >= W ||
    y < 0 || y >= W ||
    z < 0 || z >= W) {
        return 0;
    }
    return leaves[currentLeafIndex].blocks[getBlockInd(x, y, z)];
}

uint getBlockInd(int x, int y, int z) {
    return x + W * y + W * W * z;
}

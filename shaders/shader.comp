#version 450

#define W 8
#define MAX_B W*W*W

struct Vertex {
    vec3 position;
    vec2 texCoord;
};

layout(std140, binding = 0) buffer Vertices {
    Vertex vertices[];
};

layout(std430, binding = 1) buffer Indices {
    uint indices[];
};

layout(std430, binding = 2) buffer DrawCommand {
    uint    indexCount;
    uint    instanceCount;
    uint    firstIndex;
    int     vertexOffset;
    uint    firstInstance;
};

struct VoxelTreeLeaf {
    uint blocks[MAX_B];
};

struct VoxelTreeNode {
    uint height;
    uint children[4];
    uint leaf;
    int x;
    int y;
};

layout(std430, binding = 3) buffer VoxelTreeNodes {
    uint rootNodeIndex;
    uint lastNodeIndex;
    VoxelTreeNode nodes[];
};

layout(std430, binding = 4) buffer VoxelTreeLeaves {
    uint lastLeafIndex;
    VoxelTreeLeaf leaves[];
};

layout (local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

// Index of the lastly available vertex buffer index
uint vInd = 0;
// Index of the lastly available index buffer index
uint iInd = 0;
uint currentLeafIndex = 0;
uint currentNodeIndex = 0;

uint addVertex(vec3 pos, vec2 texCoord);
void addSquare(uint a, uint b, uint c, uint d);
void setupDrawCommand();
void drawCube(int x, int y, int z);
uint getBlock(int x, int y, int z);
uint getBlockInd(int x, int y, int z);

void main()
{
    uint index = gl_GlobalInvocationID.x;
    for (currentNodeIndex = 0; currentNodeIndex < lastNodeIndex; currentNodeIndex ++) {
        if (nodes[currentNodeIndex].leaf != -1) {
            currentLeafIndex = nodes[currentNodeIndex].leaf;
            for (int x = 0; x < W; x ++) {
                for (int y = 0; y < W; y ++) {
                    for (int z = 0; z < W; z ++) {
                        if (leaves[currentLeafIndex].blocks[getBlockInd(x, y, z)] > 0) {
                            drawCube(x, y, z);
                        }
                    }
                }
            }
        }
    }

    setupDrawCommand();
}

uint addVertex(vec3 pos, vec2 texCoord) {
    vertices[vInd].position = pos;
    vertices[vInd].texCoord = texCoord;
    return vInd++;
}

void addSquare(uint a, uint b, uint c, uint d) {
    indices[iInd++] = a;
    indices[iInd++] = b;
    indices[iInd++] = c;

    indices[iInd++] = c;
    indices[iInd++] = d;
    indices[iInd++] = a;
}

void setupDrawCommand() {
    indexCount = iInd;
    instanceCount = 1;
    firstIndex = 0;
    vertexOffset = 0;
    firstInstance = 0;
}

void drawCube(int x, int y, int z) {
    x += W * nodes[currentNodeIndex].x;
    y += W * nodes[currentNodeIndex].y;

    // Back side
    uint a, b, c, d;
    if (getBlock(x, y, z - 1) == 0) {
        a = addVertex(vec3(x + 1, y, z), vec2(0, 1));
        b = addVertex(vec3(x, y, z), vec2(1, 1));
        c = addVertex(vec3(x, y + 1, z), vec2(1, 0));
        d = addVertex(vec3(x + 1, y + 1, z), vec2(0, 0));
        addSquare(a, b, c, d);
    }

    // Front side
    if (getBlock(x, y, z + 1) == 0) {
        a = addVertex(vec3(x, y, z + 1), vec2(0, 1));
        b = addVertex(vec3(x + 1, y, z + 1), vec2(1, 1));
        c = addVertex(vec3(x + 1, y + 1, z + 1), vec2(1, 0));
        d = addVertex(vec3(x, y+ 1, z + 1), vec2(0, 0));
        addSquare(a, b, c, d);
    }

    // Left side
    if (getBlock(x - 1, y, z) == 0) {
        a = addVertex(vec3(x, y, z), vec2(0, 1));
        b = addVertex(vec3(x, y, z + 1), vec2(1, 1));
        c = addVertex(vec3(x, y + 1, z + 1), vec2(1, 0));
        d = addVertex(vec3(x, y + 1, z), vec2(0, 0));
        addSquare(a, b, c, d);
    }

    // Right side
    if (getBlock(x + 1, y, z) == 0) {
        a = addVertex(vec3(x + 1, y, z + 1), vec2(0, 1));
        b = addVertex(vec3(x + 1, y, z), vec2(1, 1));
        c = addVertex(vec3(x + 1, y + 1, z), vec2(1, 0));
        d = addVertex(vec3(x + 1, y + 1, z + 1), vec2(0, 0));
        addSquare(a, b, c, d);
    }

    // Bottom side
    if (getBlock(x, y - 1, z) == 0) {
        a = addVertex(vec3(x, y, z + 1), vec2(0, 1));
        b = addVertex(vec3(x, y, z), vec2(1, 1));
        c = addVertex(vec3(x + 1, y, z), vec2(1, 0));
        d = addVertex(vec3(x + 1, y, z + 1), vec2(0, 0));
        addSquare(a, b, c, d);
    }

    // Top side
    if (getBlock(x, y + 1, z) == 0) {
        a = addVertex(vec3(x, y + 1, z), vec2(0, 1));
        b = addVertex(vec3(x, y + 1, z + 1), vec2(1, 1));
        c = addVertex(vec3(x + 1, y + 1, z + 1), vec2(1, 0));
        d = addVertex(vec3(x + 1, y + 1, z), vec2(0, 0));
        addSquare(a, b, c, d);
    }
}

uint getBlock(int x, int y, int z) {
    if (
    x < 0 || x >= W ||
    y < 0 || y >= W ||
    z < 0 || z >= W) {
        return 0;
    }
    return leaves[currentLeafIndex].blocks[getBlockInd(x, y, z)];
}

uint getBlockInd(int x, int y, int z) {
    return x + W * y + W * W * z;
}
